import 'package:dart_mappable/dart_mappable.dart';
import 'package:flutter/material.dart';

import '../../core/extensions/app_localization_extension.dart';
import '../../utils/immutable_list.dart';
import 'school_color_hook.dart';

// Will be generated by dart_mappable
part 'school.mapper.dart';

typedef SchoolId = int;

@MappableClass()
class School with SchoolMappable {
  final SchoolId id;
  final String name;
  final String imageUrl;
  @MappableField(hook: DateTimeHook())
  final DateTime? foundationDate;
  final String godmotherSchool;
  final ImmutableList<String> colors;
  final ImmutableList<String> symbols;
  final SchoolCategory carnivalCategory;
  final int divisionNumber;
  final int? subdivisionNumber;
  final int firstDivisionChampionships;
  final String country;
  final String leagueLocation;
  final int lastPosition;
  final String translatedName;
  final ImmutableList<String> translatedColors;
  final ImmutableList<String> translatedSymbols;
  final String translatedGodmotherSchool;
  final String translatedCountry;
  final String translatedLeagueLocation;
  @MappableField(hook: SchoolColorHook(), key: 'colors')
  final ImmutableList<Color> colorsCode;
  @MappableField(key: 'divisionNumber')
  final SchoolDivision currentDivision;

  static const fromMap = SchoolMapper.fromMap;
  static const fromJson = SchoolMapper.fromJson;

  const School({
    required this.id,
    required this.name,
    required this.translatedName,
    required this.imageUrl,
    required this.foundationDate,
    required this.godmotherSchool,
    required this.colors,
    required this.colorsCode,
    required this.symbols,
    required this.carnivalCategory,
    required this.currentDivision,
    required this.divisionNumber,
    required this.subdivisionNumber,
    required this.firstDivisionChampionships,
    required this.country,
    required this.leagueLocation,
    required this.lastPosition,
    required this.translatedColors,
    required this.translatedSymbols,
    required this.translatedGodmotherSchool,
    required this.translatedLeagueLocation,
    required this.translatedCountry,
  });
}

@MappableEnum(caseStyle: CaseStyle.upperCase)
enum SchoolCategory {
  @MappableValue('Escolas de samba')
  escolasDeSamba,
  @MappableValue('Escolas mirins')
  escolasMirins,
  @MappableValue('Blocos de enredo')
  blocoDeEnredo,
  @MappableValue('Blocos de rua')
  blocoDeRua,
}

class _SchoolDivisionConstants {
  static const int especial = 1;
  static const int ouro = 2;
  static const int prata = 3;
  static const int bronze = 4;
  static const int avaliacao = 5;
  static const int mirins = 6;
  static const int blocosDeEnredo1 = 7;
  static const int blocosDeEnredo2 = 8;
  static const int blocosDeRua = 9;
}

@MappableEnum()
enum SchoolDivision {
  @MappableValue(_SchoolDivisionConstants.especial)
  especial,
  @MappableValue(_SchoolDivisionConstants.ouro)
  ouro,
  @MappableValue(_SchoolDivisionConstants.prata)
  prata,
  @MappableValue(_SchoolDivisionConstants.bronze)
  bronze,
  @MappableValue(_SchoolDivisionConstants.avaliacao)
  avaliacao,
  @MappableValue(_SchoolDivisionConstants.mirins)
  mirins,
  @MappableValue(_SchoolDivisionConstants.blocosDeEnredo1)
  blocosDeEnredo1,
  @MappableValue(_SchoolDivisionConstants.blocosDeEnredo2)
  blocosDeEnredo2,
  @MappableValue(_SchoolDivisionConstants.blocosDeRua)
  blocosDeRua
}

enum SchoolSort { lastPerformance, name, location, foundationDate }

extension SchoolSortExtension on SchoolSort {
  String fullName(BuildContext context) => switch (this) {
        (SchoolSort.name) => context.loc.schoolSortByName,
        // (SchoolSort.ranking) => context.loc.schoolSortByRanking,
        (SchoolSort.lastPerformance) => context.loc.schoolSortByLastPerformance,
        (SchoolSort.location) => context.loc.schoolSortByLocation,
        (SchoolSort.foundationDate) => context.loc.schoolFoundationDate,
      };
}

class DateTimeHook extends MappingHook {
  const DateTimeHook();

  @override
  Object? beforeDecode(Object? value) {
    if (value is String) {
      //1946/6/24
      if (value.isEmpty) return null;
      final data = value.trim().split('/');

      return DateTime(
        int.parse(data.first),
        data.length > 1 ? int.parse(data[1]) : 1,
        data.length > 2 ? int.parse(data[2]) : 1,
      );
    }
    throw Exception('Date $value is not valid');
  }
}
